https://kubernetes.io/docs/tutorials/kubernetes-basics/
https://medium.com/@shoaib_masood/metallb-network-loadbalancer-minikube-335d846dfdbe
https://medium.com/faun/metallb-configuration-in-minikube-to-enable-kubernetes-service-of-type-loadbalancer-9559739787df
https://github.com/t0mm4rx/ft_services

Docker install:
Brew install docker
Brew install docker-machine
Install virtual box
Script

Docker use:
# Build a docker image from a Dockerfile
docker build -t <your image name> <your Dockerfile dir>
# Start an instance of a docker image
docker run -it <your image name>
# Really important if you want to bind some ports on the container to your own computer, use -p option.
# Exemple for an Apache image using port 80 in the container as our port 80
docker run -it debian:apache -p80:80
# See all images
docker images
# See running containers
docker ps
# Stop a container
docker kill <container ID>
# Delete all unused Docker images and cache and free SO MUCH SPACE on your computer
docker system prune
#View content of a docker image, through a shell
Docker run -it image sh

Minikube:
minikube delete -p minikube
Virtualbox -> settings -> system -> processor -> 2cores


__NOTES__

First have a kubernetes cluster, after you can deploy your containers on it.
For this you need to create deployment and then expose it publicly via a service.

To deploy your containers, you need a kubernetes deployment configuration, this will instruct the master node how to create and update. This will constantly monitor the containers, if one container goes down it replaces it with another node, allowing recovery from machine failure.
To create one you need to use Kubectl, it uses the kubernetes api to interact with the cluster.

A node is a worker machine, each node is managed by the kubernetes master. Each node contains one or more pods.
Every kubernetes node runs at least;
-Kubelet, a process responsible for communication between node and master, it manages the pods and containers on a machine.
-A container runtime like docker (that sits in a pod), responsible for unpacking the container, pulling the container image and running the application.

A pod is a group of one or more containers that have shared resources, like IP address and port. By creating a deployment pods are created.
Each pod is tied to a node until termination. In case of a failure identical pods are scheduled on other nodes.

A service is a grouping of pods, the set of pods is determined by a LabelSelector. Services allow you to receive traffic and can be exposed in different ways for example through a load balancer.
The load balancer assigns a fixed external IP ti the service, allowing you to not exposing the nodes themselves and giving one endpoint (entry point).

TODO:
- Master node / Deployment - kubectl
- Node
- Service - LabelSelector - Loadbalancer
- Pod - YAML
- Container - Docker
- Img

HOW TO RUN MULTIPLE INSTANCES - Not necessary for ft_service
For increased traffics calling is necessary, this is done through changing the number of replicas.

YAML files describe kubernetes objects. Here we need to create for each container a service and deployment object. Plus for the containers that need to rememeber data a volume object.
At its core volume is just a directory that contains data. When your container stops running, the data in the volume directory is not lost. Kubernetes can restart the container as in its previous state
by using the data available in the volume directory. Different volume types exist but we will use the simplest persistentVolumeClaim, for the following data containing containers: influxdb, mysql

CONTAINERS
Wordpress - -
Mysql - -
Phpmyadmin - -
Influxdb - -
Grafana - - Generate grafana.db
ftps - -
nginx - -

FT_SERVICE
Try to make one service run with example -> https://medium.com/faun/metallb-configuration-in-minikube-to-enable-kubernetes-service-of-type-loadbalancer-9559739787df
Try to make each service run separatly
